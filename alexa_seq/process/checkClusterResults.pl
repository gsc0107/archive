#!/usr/bin/perl -w
#Written by Malachi Griffith
#Copyright 2009 Malachi Griffith
#This file is part of 'ALEXA-Seq'
#ALEXA-Seq is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#ALEXA-Seq is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#You should have received a copy of the GNU General Public License along with ALEXA-Seq (COPYING.txt).  If not, see <http://www.gnu.org/licenses/>.

#The purpose of this script is to check an input directory generated by mqsub for a cluster job and identify jobs that may have failed
#For those jobs identified, the commands will be retrieved and compiled into a new batch of jobs to be repeated
#For now, this script just works for BLAST jobs, but it can be updated to deal with new job types as needed

use strict;
use Data::Dumper;
use Getopt::Long;
use Term::ANSIColor qw(:constants);
use File::Basename;

my $input_file = '';   #Directory of command, output and error files generated by mqsub run
my $output_file = ''; #New batch file to be written containing jobs to be repeated

GetOptions ('input_file=s'=>\$input_file, 'output_file=s'=>\$output_file);

print GREEN, "\n\nUsage:", RESET;
print GREEN, "\n\tSpecify the batch file containing jobs to to be checked using:  --input_file", RESET;
print GREEN, "\n\tSpecify the batch file to be created containing jobs to be repeated using:  --output_file", RESET;
print GREEN, "\n\nExample:  checkClusterResults.pl  --input_file=/projects/malachig/solexa/batch_jobs/HS04391/blast_vs_introns_v49/blast_W11_versus_Introns_v49_Lanes1-23.sh  --output_file=/projects/malachig/solexa/batch_jobs/HS04391/blast_vs_introns_v49/blast_W11_versus_Introns_v49_Lanes1-23_REPAIR_A.sh\n\n", RESET;

unless ($input_file && $output_file){
  print RED, "\nRequired input parameter(s) missing\n\n", RESET;
  exit();
}

#Go through the input file and get a list of expected results files
print BLUE, "\nGetting list of results files from: $input_file\n", RESET;
my %jobs;
open (IN, "$input_file") || die "\nCould not open input batch file: $input_file\n\n";

my $c = 0;
while(<IN>){
  chomp($_);
  my $line = $_;
  unless ($_ =~ /blastall|bwa\saln/){
    print YELLOW, "\nLine: $_ does not contain a blast command...", RESET;
    next();
  }
  if ($_ =~ /\s+(\S+)$/){
    $c++;
    $jobs{$c}{result_file} = $1;
    $jobs{$c}{result_file_gz} = "$1".".gz";
    $jobs{$c}{line} = $line;
    $jobs{$c}{result_file_found} = 0;
    $jobs{$c}{result_file_valid} = 0;
    $jobs{$c}{result_file_lines} = 0;
    $jobs{$c}{result_file_corrupt} = 0;
    $jobs{$c}{result_file_duplicated} = 0;
    $jobs{$c}{result_file_status} = 1;

  }else{
    print RED, "\nBlast command line not understood\n\n", RESET;
    exit();
  }
}
close(IN);
my $job_count = keys %jobs;

my $result_files_found = 0;
my $result_files_missing = 0;
my $result_files_corrupt = 0;
my $result_files_nonzero = 0;
my $result_files_zero = 0;
my $result_files_duplicated = 0;
my $failed_jobs = 0;

print BLUE, "\nProcessing $job_count jobs\n", RESET;
print BLUE, "\n\tBlue dot   - file looks good", RESET;
print RED, "\n\tRed dot    - file is missing", RESET; 
print MAGENTA, "\n\tPurple dot - file is corrupt or incomplete", RESET;
print YELLOW, "\n\tYellow dot - file is empty", RESET;
print CYAN, "\n\tCyan dot - file exists in both compressed and uncompressed forms\n\n", RESET;

foreach my $c (sort {$a <=> $b} keys %jobs){

  #Check for cases where both a results file AND a compressed results file are present
  if (-e $jobs{$c}{result_file_gz} && -e $jobs{$c}{result_file}){
    $jobs{$c}{result_file_status} = 0;
    $jobs{$c}{result_file_duplicated} = 1;
    $result_files_duplicated++;
  }elsif (-e $jobs{$c}{result_file_gz}){
    #See if the result file is present
    $jobs{$c}{result_file_found} = 1;
    $result_files_found++;
  
    #If present, check that it has some results (not just and empty file) and that all lines are valid blast records
    open (BLAST_RESULTS, "zcat $jobs{$c}{result_file_gz} |") || die "\nCould not open blast results file: $jobs{$c}{result_file_gz}\n\n";

    while (<BLAST_RESULTS>){
      chomp($_);
      my @line = split ("\t", $_);
      my $fields = scalar(@line);

      #Don't consider empty lines, populated lines must have 12 standard fields
      if ($fields == 0){
        next();
      }

      #Check for truncated lines
      unless ($fields == 12){
        $jobs{$c}{result_file_corrupt} = 1;
        $result_files_corrupt++;
        $jobs{$c}{result_file_status} = 0;
      }
      $jobs{$c}{result_file_lines}++;
    }

    #Check for files with no data
    if ($jobs{$c}{result_file_lines} > 0){
      $result_files_nonzero++;
    }else{
      $result_files_zero++;
      $jobs{$c}{result_file_status} = 0;
    }
  }else{
    $jobs{$c}{result_file_status} = 0;
    $result_files_missing++;
  }

  if ($jobs{$c}{result_file_status} == 1){
    $| = 0; print BLUE, ".", RESET; $| = 1;
  }elsif($jobs{$c}{result_file_found} == 0){
    $| = 0; print RED, ".", RESET; $| = 1;
  }elsif($jobs{$c}{result_file_lines} == 0){
    $| = 0; print YELLOW, ".", RESET; $| = 1;
  }elsif($jobs{$c}{result_file_corrupt} == 1){
    $| = 0; print MAGENTA, ".", RESET; $| = 1;
  }elsif($jobs{$c}{result_file_duplicated} == 1){
    $| = 0; print CYAN, ".", RESET; $| = 1;
  }

  #Final accounting of failed jobs
  if ($jobs{$c}{result_file_status} == 0){
    $failed_jobs++;
  }
}

print BLUE, "\n\nFound $job_count total jobs", RESET;
print BLUE, "\nFound $result_files_found compressed result files", RESET;
print BLUE, "\nA total of $result_files_missing compressed result files were missing", RESET;
print BLUE, "\nA total of $result_files_corrupt compressed result files were corrupt/incomplete", RESET;
print BLUE, "\nA total of $result_files_zero compressed result files were empty", RESET;
print BLUE, "\nA total of $result_files_duplicated results exist in both compressed and uncompressed form", RESET;

my $jobs_printed = 0;
if ($failed_jobs == 0){
  print BLUE, "\n\nNo failed jobs!! No need for repeats.\n\n", RESET;
  my $cmd = "rm -f $output_file";
  system($cmd);
}else{

  #Print a new batch file with jobs that need to be repeated
  open (OUT, ">$output_file") || die "\nCould not open output file: $output_file\n\n";
  foreach my $c (sort {$a <=> $b} keys %jobs){
    unless ($jobs{$c}{result_file_status} == 1){
      print OUT "$jobs{$c}{line}\n";
      $jobs_printed++;
    }
  }
  close(OUT);
  print BLUE, "\n\nPrinted $jobs_printed jobs to the new batch file:\n\t$output_file\n\n", RESET;
}

#If zero jobs were printed, wipe the repair file
if ($jobs_printed == 0){
  my $cmd = "rm -f $output_file";
  system($cmd);
}

exit();
